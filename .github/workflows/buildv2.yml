name: Build CounterStrikeSharp Plugin

on:
  push:
    branches: [ main, master ]
    tags:     [ 'v*' ]
  pull_request:
    branches: [ main, master ]

permissions:
  contents: write

env:
  DOTNET_VERSION: '8.0.x'
  CONFIGURATION: Release
  # Chemin RELATIF vers le projet (ici deviné pour ton repo)
  PLUGIN_PROJECT: 'AFKManager/AFKManager.csproj'
  CSS_PLUGIN_DIR: addons/counterstrikesharp/plugins

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}
          # pas de cache nuget par lockfile pour éviter l'erreur "Dependencies lock file is not found"

      - name: Detect project file
        id: detect
        shell: bash
        run: |
          set -euo pipefail

          # Normalisation de PLUGIN_PROJECT (avec ou sans .csproj)
          if [[ -n "${PLUGIN_PROJECT}" ]]; then
            if [[ -f "$PLUGIN_PROJECT" && "$PLUGIN_PROJECT" == *.csproj ]]; then
              proj="$PLUGIN_PROJECT"
            elif [[ -f "${PLUGIN_PROJECT%.csproj}.csproj" ]]; then
              proj="${PLUGIN_PROJECT%.csproj}.csproj"
            else
              echo "::error::PLUGIN_PROJECT défini mais introuvable: '$PLUGIN_PROJECT'"
              exit 1
            fi
          else
            mapfile -t candidates < <(git ls-files '**/*.csproj' | grep -Ev '/(bin|obj)/' || true)
            count=${#candidates[@]}
            if (( count == 0 )); then
              echo "::error::Aucun .csproj trouvé. Renseigne env.PLUGIN_PROJECT."
              exit 1
            elif (( count > 1 )); then
              echo "::error::Plusieurs .csproj trouvés. Spécifie env.PLUGIN_PROJECT."
              printf '%s\n' "${candidates[@]}"
              exit 1
            else
              proj="${candidates[0]}"
            fi
          fi

          base="$(basename "$proj" .csproj)"
          dir="$(dirname "$proj")"

          echo "proj=$proj" >> "$GITHUB_OUTPUT"
          echo "base=$base" >> "$GITHUB_OUTPUT"
          echo "dir=$dir"   >> "$GITHUB_OUTPUT"

          echo "Projet détecté: $proj (base=$base, dir=$dir)"

      - name: Restore
        run: dotnet restore "${{ steps.detect.outputs.proj }}"

      - name: Build
        run: dotnet build "${{ steps.detect.outputs.proj }}" -c $CONFIGURATION --no-restore -p:ContinuousIntegrationBuild=true

      - name: Test
        if: hashFiles('**/*Tests.csproj') != ''
        run: |
          set -e
          while IFS= read -r t; do
            dotnet test "$t" -c $CONFIGURATION --no-build --logger "trx;LogFileName=test-results.trx"
          done < <(git ls-files "**/*Tests.csproj" || true)

      - name: Locate built DLL
        id: dll
        shell: bash
        run: |
          set -euo pipefail
          search_root="${{ steps.detect.outputs.dir }}/bin/${{ env.CONFIGURATION }}"
          [[ -d "$search_root" ]] || search_root="."
          dll=$(find "$search_root" -type f -name "${{ steps.detect.outputs.base }}.dll" | head -n1 || true)
          if [[ -z "$dll" ]]; then
            echo "::error::DLL non trouvée. Vérifie que le projet est une class library et le nom attendu."
            exit 1
          fi
          echo "path=$dll" >> "$GITHUB_OUTPUT"
          echo "name=${{ steps.detect.outputs.base }}" >> "$GITHUB_OUTPUT"
          echo "DLL: $dll"

      - name: Package (server-ready zip)
        id: pkg
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p out/${{ env.CSS_PLUGIN_DIR }}
          cp "${{ steps.dll.outputs.path }}" "out/${{ env.CSS_PLUGIN_DIR }}/"

          # Optionnel: fichiers utiles à la racine du zip
          for f in LICENSE* README*; do
            [[ -e "$f" ]] && cp "$f" out/ || true
          done

          # Optionnel: configs JSON depuis le dossier du projet
          projdir="${{ steps.detect.outputs.dir }}"
          if compgen -G "$projdir/*.json" > /dev/null; then
            cp "$projdir/"*.json "out/${{ env.CSS_PLUGIN_DIR }}/" || true
          fi

          zipname="${{ steps.dll.outputs.name }}-artifact.zip"
          (cd out && zip -r "../$zipname" .)
          echo "zip=$zipname" >> "$GITHUB_OUTPUT"

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.dll.outputs.name }}-${{ github.sha }}
          path: |
            ${{ steps.pkg.outputs.zip }}
            **/bin/${{ env.CONFIGURATION }}/**/*.dll
          if-no-files-found: error
          retention-days: 7

      - name: Create GitHub Release (on tag)
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v2
        with:
          files: ${{ steps.pkg.outputs.zip }}
          generate_release_notes: true
